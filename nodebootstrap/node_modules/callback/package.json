{
  "author": {
    "name": "Marty Nelson",
    "email": "@martypdx"
  },
  "name": "callback",
  "description": "Expressive, terse, functions for aynchronous and callback functions",
  "version": "0.0.1",
  "homepage": "https://github.com/martypdx/callback.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/martypdx/callback.js.git"
  },
  "main": "./lib/callback.js",
  "keywords": [
    "async",
    "asynchronous",
    "flow",
    "flow control",
    "step",
    "callback",
    "callbacks"
  ],
  "engines": {
    "node": "~0.6.6"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "*",
    "should": "*",
    "colors": "*"
  },
  "readme": "# callback\r\n\r\nExpressive, terse, functions for asynchronous and callback functions.\r\n\r\nThe real issue with asynchronous coding isn't flow control, \r\nit's mediating between asynchronous functions with signature:\r\n\r\n\tfunction async([arg1, [arg2, [...]],] cb) { ... }\r\n\r\nand the callback signature:\r\n\r\n\tfunction callback(err, result) { ... }\r\n\r\n*callback* extends `Function.prototype` and allows you to write code like:\r\n\r\n\tfunction rimraf(d, cb) {  \r\n\t\tif(!d.isDirectory) {\r\n\t\t\treturn stat(d, rimraf.use(cb) )\r\n\t\t}\r\n\r\n\t\tdir.if(d.isDirectory()).else(fs.unlink)(d.path, cb)\r\n\r\n\t\tfunction dir(d, cb) {\t\t\r\n\t\t\treaddir(d, rimraf.each(fs.rmdir.pass(d, cb)))\r\n\t\t}\r\n\t}\r\n\r\n\tvar stat = fs.stat.adapt(function(stat, path) {\r\n\t\t\tstat.path = path\r\n\t\t\treturn stat\r\n\t\t})\r\n\t ,\treaddir = fs.readdir.adapt(function(files, d){\r\n\t\t\treturn files.map(function(f){\r\n\t\t\t\treturn path.join(d, f) \r\n\t\t\t})\r\n\t\t})\r\n\r\nor:\r\n\r\n\tfs.readFile( __filename, 'utf-8', console.log.cb(upper) )\r\n\r\n\tfunction upper(data) {\r\n\t  return data.toUpperCase()\r\n\t}\r\n\r\n*callback* doesn't assume or dictate any particular coding style. \r\nDoesn't require creating library objects to manage your functions\r\nor try to pretend you're writing synchronous code.\r\n\r\nUse as much or as little as you like.\r\n\r\n## Install\r\n\r\n\tnpm install callback\r\n\r\n# Functions for Asynchronous Functions\r\n\r\nThese functions are used with asynchronous functions of type:\r\n\r\n    function async([arg1, [arg2, [...]],] cb)\r\n\r\nwhich are wrapped to be used as callbacks:\r\n\r\n\tasync.use(cb)\r\n\r\n## use ( [transform,] cb )\r\n\r\nTurns an asynchronous function into a callback and includes the \r\nresults of the callback in the invocation of the function:\r\n\r\n\tf1(input, f2.use(cb))\r\n\t\r\nis equivalent to:\r\n\r\n\tf1('input', function(err, result) {\r\n\t\tif(err) return cb(err)\r\n\t\tf2(result, cb)\r\n\t})\r\n\r\nAn optional transformation can be included that should be a *synchronous* \r\nfunction that accepts the results and returns the transformed results:\r\n\r\n\tfunction addText(result) { return result + ' added text'  }\r\n\r\nThe transformation is included *before* the cb argument:\r\n\r\n\tf1(input, f2.use(addText, cb))\r\n\r\nis equivalent to:\r\n\r\n\tf1('input', function(err, result) {\r\n\t\tif(err) return cb(err)\r\n\t\tf2(addText(result), cb)\r\n\t})\r\n\r\n`use` is intended for asynchronous functions that have one input argument:\r\n\r\n\tf(input, cb)\r\n\r\nFor functions that have no input arguments, or more than one argument, \r\nsee `pass` and `add`. If you need to modify the results passed on input \r\nparameters to the original asynchronous function, see `adapt`.\r\n\r\n## then ( [f1, [f2, [...]],] cb )\r\n\r\nSince `use` can be combined to do sequential callbacks:\r\n\r\n\tf1(input, f2.use( f2.use(cb) ) )\r\n\r\n`then` offers a short-hand way to accomplish the same thing:\r\n\r\n\tf1(input, f2.then(f2, cb))\r\n\r\nAssuming they are all of type `f(input, cb)`, `then` can take multiple async functions\r\nbefore the final callback function:\r\n\r\n\tf(input, f2.then(f3, f4, f5, f6, cb)) \r\n\r\n## add ( [arg1, [arg2, [...]],] cb )\r\n\r\nUse `add` to add arguments *in addition to* the callback result argument\r\nwhich will be included as the first argument:\r\n\r\n\tsomeFn( 'input', fs.open.add('a', cb) )\r\n\r\nis equivalent to:\r\n\r\n\tsomeFn( 'input', function(err, result) {\r\n\t\tif(err) return cb(err)\r\n\t\tfs.open(result, 'a', cb)\r\n\t})\r\n\r\nCalling `add` with only the callback: `asyncFn.add(cb)` is equivalent to calling `asyncFn.use(cb)`.\r\n\r\nUnlike `use`, add does not take a transformation. You can add `adapt` or `xform` to achieve the same results.\r\n\r\n`add` uses `apply` on the target function, so currently it is not useful on functions that require `this` context.\r\n\r\n## pass ( [arg1, [arg2, [...]],] cb )\r\n\r\nUse `pass` to indicate the _exact_ arguments to be passed to the async function being used for the callback. \r\nUnlike `add` or `use`, the callback result is discarded:\r\n\r\n\tsomeFn( 'input', fs.rmdir.pass(dir, cb) )\r\n\r\nis equivelent to:\r\n\r\n\tsomeFn( 'input', function(err, result) {\r\n\t\tif(err) return cb(err)\r\n\t\tfs.rmdir(dir, cb)\r\n\t})\r\n\r\n`pass` can also be used for async functions that take no input except for a callback \r\n(whereas `use` and `add` will always pass the result as the first argument).\r\n\r\n`pass` uses `apply` on the target function, so currently it is not useful on functions that require `this` context.\r\n\r\n## each ( [transform,] cb )\r\n\r\n`each` calls an asynchronous function in parallel based on a callback result that can be called with `forEach`. \r\nResults are combined into an array which is passed as the result to `cb` after all invocations of the \r\nunderlying function have completed:\r\n\r\n\tfs.readdir(dir, fs.open.each(cb))\r\n\r\nis equivalent to:\r\n\r\n\tfs.readdir(dir, function(err, result) {\r\n\t\tif(err) return cb(err)\r\n\t\tvar count = result.length\r\n\t\tif(count === 0) return cb(null, [])\r\n\r\n\t\tvar\terrState = null\r\n\t\t ,\tresults = []\r\n\t\t ,\tdone = function(err, eachResult) {\r\n\t\t\t\tif (errState) return\r\n\t\t\t\tif (err) return cb(errState = err)\r\n\t\t\t\tif (results.push(eachResult) === count) {\r\n\t\t\t\t\tcb(null, results)\t\r\n\t\t\t\t}\r\n \t\t\t}\r\n\r\n\t\tresult.forEach(function(each) {\r\n\t\t\tfs.open(each, done)\r\n\t\t})\r\n\t})\r\n\r\n## adapt (transform)\r\n\r\nModifies the invocation of the callback of an asynchronous function:\r\n\r\n\tf.adapt(upper)(input, cb)\r\n\r\nis equivalent to:\r\n\r\n\tf(input, function(err, result){\r\n\t\tcb(err, upper(result, input))\r\n\t})\r\n\r\nNote that any (and all) arguments passed to `f` are added to the tranformation \r\nfunction. Useful for modifying callback results with original input\r\narguments:\r\n\r\n\tvar readdir = fs.readdir.adapt(function(files, d){\r\n\t\treturn files.map(function(f){\r\n\t\t\treturn path.join(d, f) \r\n\t\t})\r\n\t})\r\n\r\n# Functions for Synchronous Functions\r\n\r\nThese functions are used with synchronous functions that have no callback,\r\nof signature type:\r\n\r\n    function sync([arg1, [arg2, [...]],])\r\n\r\nsuch as\r\n\r\n\tconsole.log.cb\r\n\r\nTypically, these would be used as endpoints for asynchronous function chains.\t\r\n\r\nThese functions will throw any err received on callback. \r\nSee `err` to provide an alternative behavior.\r\n\r\n## cb [ (transform) ]\r\n\r\nAdapts a synchronous function by passing the callback \r\nresults as the first argument. Note that the version without a transformation\r\n_is a property getter_ and not a method:\r\n\r\n\tconsole.log.cb\r\n\r\nOptionally accepts a transformation:\r\n\r\n\tfs.readFile(__filename, console.log.cb(upper))\r\n\tfunction upper(text) { \r\n\t\treturn text.toUpperCase() \r\n\t}\r\n\r\n`cb` will throw any `err` received on the callback. See `err` to modify the error\r\nhandling of the callback.\r\n\r\n## with ( [arg1, [arg2, [...]],] )\r\n\r\nLike `cb`, except that `with` allows the specification of arguments *before*\r\nthe callback result:\r\n\r\n\tfs.readFile( __filename, console.log.with('%s') )\r\n\r\nUseful for specifying the template on response render:\r\n\r\n\tapp.get('/user/:id', function (req, res) {\r\n\t    getUser( req.params.id, res.render.with('user') )\r\n\t})\r\n\r\n`with` will throw any err received on the callback. See `err` to modify the error\r\nhandling of the callback.\r\n\r\n# Functions for Callback Functions\r\n\r\nThese functions modify existing callback functions but still retain the callback signature.\r\n\r\n## err (handler)\r\n\r\nCauses an err to be routed to the supplied function for handling:\r\n\r\n\tfunction errHandler(err) {...}\r\n\tf(input, cb.err(errHandler))\r\n\r\nThe callback chain is aborted, the modified callback is not called. \r\n\r\nUseful for synchronous methods adapted for callback:\r\n\r\n\tres.render.with('template').err(function(err) { ... })\r\n\r\nor:\r\n\r\n\tfunction error(err) {\r\n\t\tconsole.log('error:', err)\r\n\t}\r\n\tconsole.log.cb.err(error)\r\n\r\n## xform (transform)\r\n\r\nCalls the supplied transformation function of signature:\r\n\r\n\tf(result) {...}\r\n\r\nwith the callback result and uses the return value as the result argument for \r\nthe underlying callback:\r\n\r\n\tf(input, cb.xform(function(r) {\r\n\t\treturn r.data\r\n\t}))\r\n\r\nis equivalent to:\r\n\r\n\tf(input, function(err, result){\r\n\t\tcb(err, result.data)\r\n\t})\r\n\r\nMore useful when combined with other functions like `then` that don't directly \r\ntake a transform argument:\r\n\r\n\tf(input, f2.then(f3.xform(upper), f4, cb))\r\n\tfunction upper(text) {\r\n\t\treturn text.toUpperCase()\r\n\t}\r\n\r\nOr along with `with`:\r\n\r\n\tfs.readFile( __filename, console.log.with('%s')\r\n\t\t.xform(function(f) {\r\n\t\t\treturn f.toUpperCase()\r\n\t\t}))\r\n\r\n# Conditionals\r\n\r\nThese apply to any type of function:\r\n\r\n\tf.if(condition)(input)\r\n\r\nis equivalent to:\r\n\r\n\tif(condition) {\r\n\t\tf(input)\r\n\t}\r\n\r\ntechnically is:\r\n\r\n\t(condition ? f : noop)(input)\r\n\r\nCan also include an else function:\r\n\r\n\tf.if(condition).else(f2)(input, cb)\r\n\r\n# Housekeeping\r\n\r\nLooking for feedback on api and which functions are most useful.\r\nDon't want to bloat the api with speculative functionality.\r\n\r\nCurrently thinking of adding:\r\n\r\n* `map` function that collects multiple async function callback\r\nresults:\r\n\r\n\t\tf(input, target.map(f1, f2, f3, cb))\r\n\t\t//calls:\r\n\t\ttarget(f1result, f2result, f3result, cb)\r\n\r\n* possibly a filter for each:\r\n\r\n\t\ttarget.each(cb).filter(filter)\t\r\n\r\n## Tests\r\n\r\nYou can run the tests with\r\n\r\n\tcallback.js> make\r\n\r\nThe tests are done using a bit of a work-in-progress technique called\r\n_photocopy testing_. The tests work great, they're just a bit more difficult\r\nto maintain without some tooling that I have planned.\r\n\r\n## Benchmarks\r\n \r\nIn the _examples_ _rimraf_ directory is a benchmark that runs both \r\na _callback_ rimraf and a \"normal\" rimraf. The variations in file i/o\r\nseem greater than any difference.\r\n\r\nThe overhead of additional functions does not seem significant. However,\r\nI plan on expanding with some faux async functions to compare any added\r\noverhead directly.\r\n\r\n## Platform\r\n\r\nI'm currently developing on Windows, though I had cygwin installed \r\nprior to v0.6.4 - so I have POSIX like functionality even though\r\nI'm running from DOS cmd.\r\n\r\nLet me know if something doesn't work, either DOS or POSIX.\r\n\r\n## License \r\n\r\n(The MIT License)\r\n\r\nCopyright (c) 2011-2012 Marty Nelson <@martypdx>\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n'Software'), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/martypdx/callback.js/issues"
  },
  "_id": "callback@0.0.1",
  "dist": {
    "shasum": "9eb2e4176af88f2dde4c615d8897542966a83fc9"
  },
  "_from": "callback@",
  "_resolved": "https://registry.npmjs.org/callback/-/callback-0.0.1.tgz"
}
